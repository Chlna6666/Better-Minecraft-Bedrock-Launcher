name: Nightly Release

on:
  schedule:
    - cron: '0 0 * * 0'   # 注意：'0 0 * * 0' = 每周日 00:00（若要每天请改为 '0 0 * * *'）
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: nightly
  cancel-in-progress: true

jobs:
  nightly:
    runs-on: windows-latest

    steps:
      - name: 签出代码（包含 tag 和完整历史）
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 获取仓库默认分支
        id: get_default_branch
        shell: pwsh
        run: |
          $repoApi = "https://api.github.com/repos/$env:GITHUB_REPOSITORY"
          $headers = @{ Authorization = "token $env:GITHUB_TOKEN"; "User-Agent" = "github-actions" }
          Write-Host "正在请求 GitHub API 以获取默认分支信息..."
          $resp = Invoke-RestMethod -Uri $repoApi -Headers $headers
          $default = $resp.default_branch
          Write-Host "默认分支: $default"
          echo "DEFAULT_BRANCH=$default" >> $env:GITHUB_OUTPUT

      - name: 检查自上次 nightly tag 以来是否有新提交
        id: check_commits
        shell: pwsh
        run: |
          $default = "${{ steps.get_default_branch.outputs.DEFAULT_BRANCH }}"
          Write-Host "正在检查分支 $default 上是否有新提交..."
          # fetch branch head and tags
          git fetch origin $default --tags --no-recurse-submodules --depth=1

          # 查找最近的 nightly tag（格式 vX.Y.Z-nightly.YYYYMMDD）
          $latest = git tag -l "v*-nightly.*" --sort=-creatordate | Select-Object -First 1
          if (-not $latest) {
            Write-Host "未找到之前的 nightly tag -> 将进行构建。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
            exit 0
          }

          Write-Host "找到最近的 nightly tag: $latest"
          $tagCommit = git rev-list -n 1 $latest
          $tagDate = [int](git show -s --format=%ct $tagCommit)
          $headCommit = git rev-parse origin/$default
          $headDate = [int](git show -s --format=%ct $headCommit)

          Write-Host "tag 提交时间戳: $tagDate"
          Write-Host "分支 HEAD 提交时间戳: $headDate"

          if ($headDate -gt $tagDate) {
            Write-Host "自上次 nightly tag 后存在新提交 -> 将执行构建。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "自上次 nightly tag 后无新提交 -> 跳过构建。"
            echo "changed=false" >> $env:GITHUB_OUTPUT
          }

      - name: 警告（醒目标识）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          Write-Host "==================================================="
          Write-Host "⚠️  警告：这是自动化的 NIGHTLY 预发行版本（pre-release）。"
          Write-Host "可能包含不稳定代码，请谨慎使用。"
          Write-Host "==================================================="

      - name: 读取 src-tauri/Cargo.toml 中的原始版本（用于生成 tag）
        id: read_cargo_version
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $cargo_path = "src-tauri/Cargo.toml"
          if (-Not (Test-Path $cargo_path)) {
            Write-Error "未在 src-tauri 目录找到 Cargo.toml，无法从中读取版本。路径: $cargo_path"
            exit 1
          }
          $content = Get-Content $cargo_path -Raw
          # 用正则提取 version = "x.y.z"
          $m = [regex]::Match($content, 'version\s*=\s*"([^"]+)"')
          if (-not $m.Success) {
            Write-Error "无法从 src-tauri/Cargo.toml 中解析 version 字段。"
            exit 1
          }
          $orig_ver = $m.Groups[1].Value
          Write-Host "从 src-tauri/Cargo.toml 读取到版本：$orig_ver"
          echo "ORIGINAL_VERSION=$orig_ver" >> $env:GITHUB_OUTPUT
          # 备份原始 Cargo.toml 到临时文件，以便后续还原
          Set-Content -Path ".cargo_backup_src_tauri.toml" -Value $content -Encoding UTF8
          Write-Host "已备份 src-tauri/Cargo.toml 到 .cargo_backup_src_tauri.toml"

      - name: 生成 nightly tag 名称 (vX.Y.Z-nightly.YYYYMMDD)
        id: make_tag_name
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $orig = "${{ steps.read_cargo_version.outputs.ORIGINAL_VERSION }}"
          $date = (Get-Date).ToString("yyyyMMdd")
          $tag = "v$orig-nightly.$date"
          Write-Host "生成的 nightly tag: $tag"
          echo "TAG_NAME=$tag" >> $env:GITHUB_OUTPUT
          echo "NIGHTLY_VERSION=$orig-nightly.$date" >> $env:GITHUB_OUTPUT

      - name: 创建或复用 nightly tag（基于 vX.Y.Z-nightly.YYYYMMDD）
        id: create_or_reuse_tag
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $default = "${{ steps.get_default_branch.outputs.DEFAULT_BRANCH }}"
          $tag = "${{ steps.make_tag_name.outputs.TAG_NAME }}"
          Write-Host "计划使用的 tag: $tag"

          git fetch --tags

          $exists = git tag -l $tag
          if ($exists) {
            Write-Host "Tag $tag 已存在，复用该 tag（不重新创建）。"
          } else {
            Write-Host "Tag $tag 不存在，正在创建并推送到 origin..."
            git fetch origin $default
            $head = "origin/$default"
            git tag $tag $head -m "Nightly build for $tag"
            git push origin $tag
            Write-Host "已创建并推送 tag $tag"
          }

          echo "TAG_NAME=$tag" >> $env:GITHUB_OUTPUT

      - name: 临时修改 src-tauri/Cargo.toml 的版本为 nightly（原版本-nightly.YYYYMMDD）
        id: patch_cargo_version
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $orig = "${{ steps.read_cargo_version.outputs.ORIGINAL_VERSION }}"
          $nightly = "${{ steps.make_tag_name.outputs.NIGHTLY_VERSION }}"
          Write-Host "原始版本: $orig"
          Write-Host "夜间版本 (将写入 src-tauri/Cargo.toml): $nightly"

          $cargo_path = "src-tauri/Cargo.toml"
          $content = Get-Content $cargo_path -Raw
          # 替换第一个 version = "..." 字段
          $new = [regex]::Replace($content, 'version\s*=\s*"([^"]+)"', "version = `"$nightly`"", 1)
          Set-Content -Path $cargo_path -Value $new -Encoding UTF8
          Write-Host "已将 src-tauri/Cargo.toml 中的 version 修改为 nightly 版本（仅本地工作区）。"

          # 将 nightly 版本输出，以便其它步骤使用（可选）
          echo "CARGO_NIGHTLY_VERSION=$nightly" >> $env:GITHUB_OUTPUT

      - name: 设置 Node.js
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: 设置 Rust (stable)
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: dtolnay/rust-toolchain@stable

      - name: 缓存 cargo（可选）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: 安装前端依赖
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm ci
        shell: pwsh

      - name: 全局安装 @tauri-apps/cli（避免使用 npx）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm install -g @tauri-apps/cli
        shell: pwsh

      - name: 构建 Tauri
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm run tauri:build
        shell: pwsh
        env:
          CI: false

      - name: 验证 exe 是否存在并设置输出
        id: find_exe
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $expected = "src-tauri/target/release/better_minecraft_bedrock_launcher.exe"
          Write-Host "检查文件: $expected"
          if (Test-Path $expected) {
            $p = (Resolve-Path $expected).Path.Replace('\','/')
            Write-Host "找到可执行文件: $p"
            echo "EXE_PATH=$p" >> $env:GITHUB_OUTPUT
            $name = [IO.Path]::GetFileName($p)
            echo "EXE_NAME=$name" >> $env:GITHUB_OUTPUT
          } else {
            Write-Error "未找到期望的 exe 文件: $expected"
            exit 1
          }

      - name: 获取或创建对应的 Release（按 tag）并输出 upload_url
        id: get_or_create_release
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $tag = "${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
          $repo = $env:GITHUB_REPOSITORY
          $headers = @{ Authorization = "token $env:GITHUB_TOKEN"; "User-Agent" = "github-actions" }
          Write-Host "查找 tag 对应的 Release：$tag"
          try {
            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/tags/$tag" -Headers $headers -ErrorAction Stop
            Write-Host "找到已存在的 Release (id=$($release.id))"
          } catch {
            Write-Host "未找到 Release，准备创建新的 pre-release..."
            $body = @{
              tag_name = $tag
              name = "Nightly $tag"
              body = "自动化 nightly 预发行：$tag。`n`n⚠️ 警告：这是自动化生成的 nightly 预发行 (pre-release)，来自仓库默认分支的最新提交。可能包含不稳定或未充分测试的更改，请谨慎使用并在生产环境中小心部署。"
              draft = $false
              prerelease = $true
            } | ConvertTo-Json -Depth 6
            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases" -Headers $headers -Method Post -Body $body
            Write-Host "已创建 Release (id=$($release.id))"
          }
          echo "RELEASE_ID=$($release.id)" >> $env:GITHUB_OUTPUT
          echo "UPLOAD_URL=$($release.upload_url)" >> $env:GITHUB_OUTPUT

      - name: 删除 Release 中同名旧资产（如果存在）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $repo = $env:GITHUB_REPOSITORY
          $release_id = "${{ steps.get_or_create_release.outputs.RELEASE_ID }}"
          $filename = "${{ steps.find_exe.outputs.EXE_NAME }}"
          $headers = @{ Authorization = "token $env:GITHUB_TOKEN"; "User-Agent" = "github-actions" }

          Write-Host "列出 Release($release_id) 的资产并检查是否存在同名文件: $filename"
          $assets = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/$release_id/assets" -Headers $headers
          if ($assets) {
            foreach ($a in $assets) {
              if ($a.name -eq $filename) {
                Write-Host "发现同名资产 (id=$($a.id))，正在删除..."
                Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/assets/$($a.id)" -Headers $headers -Method Delete
                Write-Host "已删除旧资产 $filename (id=$($a.id))"
              }
            }
          } else {
            Write-Host "Release 中没有资产。"
          }

      - name: 上传 exe 到 GitHub Release（创建为预发行）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}
          name: "Nightly ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
          body: |
            自动化 nightly 预发行：${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}。

            ⚠️ 警告：这是自动化生成的 nightly 预发行 (pre-release)，来自仓库默认分支的最新提交。
            可能包含不稳定或未充分测试的更改，请谨慎使用并在生产环境中小心部署。
          draft: false
          prerelease: true
          files: ${{ steps.find_exe.outputs.EXE_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 还原原始 src-tauri/Cargo.toml（恢复版本）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          if (Test-Path ".cargo_backup_src_tauri.toml") {
            Get-Content ".cargo_backup_src_tauri.toml" -Raw | Set-Content "src-tauri/Cargo.toml" -Encoding UTF8
            Write-Host "已从 .cargo_backup_src_tauri.toml 恢复 src-tauri/Cargo.toml"
            Remove-Item ".cargo_backup_src_tauri.toml" -ErrorAction SilentlyContinue
          } else {
            Write-Host "未找到 .cargo_backup_src_tauri.toml，跳过恢复。"
          }

      - name: 完成提示
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          Write-Host "Nightly 预发行已上传并使用 tag: ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
