name: Nightly

on:
  schedule:
    - cron: '0 0 * * 0'
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: nightly
  cancel-in-progress: true

jobs:
  nightly:
    runs-on: windows-latest

    steps:
      - name: 签出代码（包含 tag 和完整历史）
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 获取仓库默认分支（通过 git 解析，避免调用 API 导致 token 问题）
        id: get_default_branch
        shell: pwsh
        run: |
          Write-Host "尝试通过 git 解析 origin 的 HEAD 指向以获取默认分支..."
          $ref = ""
          try {
            $ref = git symbolic-ref refs/remotes/origin/HEAD 2>$null
          } catch {
            $ref = ""
          }
          if (-not [string]::IsNullOrEmpty($ref)) {
            # refs/remotes/origin/main -> 取最后一段
            $parts = $ref -split "/"
            $default = $parts[-1]
            Write-Host "解析到默认分支（来自 origin/HEAD）: $default"
          } else {
            # fallback: 尝试通过 remote show origin
            $out = git remote show origin 2>$null | Select-String -Pattern "HEAD branch:"
            if ($out) {
              $default = ($out -replace '.*HEAD branch:\s*','').Trim()
              Write-Host "解析到默认分支（来自 remote show origin）: $default"
            } else {
              # 最后兜底为 main
              $default = "main"
              Write-Host "无法解析默认分支，使用默认值: $default"
            }
          }
          echo "DEFAULT_BRANCH=$default" >> $env:GITHUB_OUTPUT

      - name: 检查自上次 nightly tag 以来是否有新提交
        id: check_commits
        shell: pwsh
        run: |
          $default = "${{ steps.get_default_branch.outputs.DEFAULT_BRANCH }}"
          Write-Host "正在检查分支 $default 上是否有新提交..."
          
          # 先确保拿到远端最新 refs 和 tags（不要使用 --depth=1，会影响 tags）
          git fetch origin $default
          git fetch --tags origin

          # 查找最新的 nightly tag（基于 creatordate），若没有则触发构建
          $latest = git tag -l "v*-nightly.*" --sort=-creatordate | Select-Object -First 1
          if (-not $latest) {
            Write-Host "未找到之前的 nightly tag -> 将进行构建。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
            exit 0
          }

          Write-Host "找到最近的 nightly tag: $latest"

          # tag 对应的 commit（先在本地解析）
          $tagCommit = git rev-list -n 1 $latest
          if (-not $tagCommit) {
            Write-Host "无法解析 tag 的 commit，触发构建以保险。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
            exit 0
          }
          $tagDate = [int](git show -s --format=%ct $tagCommit)

          # origin/<default> 的最新 commit
          $headCommit = git rev-parse "origin/$default"
          if (-not $headCommit) {
            Write-Host "无法解析 origin/$default 的 commit，触发构建以保险。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
            exit 0
          }
          $headDate = [int](git show -s --format=%ct $headCommit)

          Write-Host "tag 提交时间戳: $tagDate"
          Write-Host "分支 HEAD 提交时间戳: $headDate"

          if ($headDate -gt $tagDate) {
            Write-Host "自上次 nightly tag 后存在新提交 -> 将执行构建。"
            echo "changed=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "自上次 nightly tag 后无新提交 -> 跳过构建。"
            echo "changed=false" >> $env:GITHUB_OUTPUT
          }

      - name: 警告（醒目标识）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          Write-Host "==================================================="
          Write-Host "⚠️  警告：这是自动化的 NIGHTLY 预发行版本（pre-release）。"
          Write-Host "可能包含不稳定代码，请谨慎使用。"
          Write-Host "==================================================="

      - name: 读取 src-tauri/Cargo.toml 中的原始版本（用于生成 tag）
        id: read_cargo_version
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $cargo_path = "src-tauri/Cargo.toml"
          if (-Not (Test-Path $cargo_path)) {
            Write-Error "未在 src-tauri 目录找到 Cargo.toml，路径: $cargo_path"
            exit 1
          }
          $content = Get-Content $cargo_path -Raw
          $m = [regex]::Match($content, 'version\s*=\s*"([^"]+)"')
          if (-not $m.Success) {
            Write-Error "无法从 src-tauri/Cargo.toml 中解析 version 字段。"
            exit 1
          }
          $orig_ver = $m.Groups[1].Value
          Write-Host "从 src-tauri/Cargo.toml 读取到版本：$orig_ver"
          echo "ORIGINAL_VERSION=$orig_ver" >> $env:GITHUB_OUTPUT
          Set-Content -Path ".cargo_backup_src_tauri.toml" -Value $content -Encoding UTF8
          Write-Host "已备份 src-tauri/Cargo.toml 到 .cargo_backup_src_tauri.toml"

      - name: 生成 nightly tag 名称 (vX.Y.Z-nightly.YYYYMMDD)
        id: make_tag_name
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $orig = "${{ steps.read_cargo_version.outputs.ORIGINAL_VERSION }}"
          $date = (Get-Date).ToString("yyyyMMdd")
          $tag = "v$orig-nightly.$date"
          Write-Host "生成的 nightly tag: $tag"
          echo "TAG_NAME=$tag" >> $env:GITHUB_OUTPUT
          echo "NIGHTLY_VERSION=$orig-nightly.$date" >> $env:GITHUB_OUTPUT

      - name: 创建或复用 nightly tag（基于 vX.Y.Z-nightly.YYYYMMDD）
        id: create_or_reuse_tag
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 在 PowerShell 中遇错时退出
          $ErrorActionPreference = "Stop"

          # 为 tag 操作设置身份（仅仓库级，不使用 --global）
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          $default = "${{ steps.get_default_branch.outputs.DEFAULT_BRANCH }}"
          $tag = "${{ steps.make_tag_name.outputs.TAG_NAME }}"
          Write-Host "计划使用的 tag: $tag (基于分支: $default)"

          # 拉取 tags 与目标分支的最新引用
          git fetch --tags origin
          git fetch origin $default

          # 获取 origin/<default> 的 commit
          $headCommit = git rev-parse "origin/$default" 2>$null
          if (-not $headCommit) {
            Write-Error "无法解析 origin/$default 的 commit，终止。"
            exit 1
          }
          Write-Host "origin/$default 的 commit: $headCommit"

          # 检查 tag 是否已存在
          $exists = git tag -l $tag
          if ($exists) {
            Write-Host "Tag $tag 已存在，复用该 tag（不重新创建）。"
          } else {
            Write-Host "Tag $tag 不存在，准备创建..."

            # 使用注释型 tag 指向 origin/$default 的 commit（需要 user.name/email）
            git tag -a $tag $headCommit -m "Nightly build for $tag"
            if ($LASTEXITCODE -ne 0) {
              Write-Error "创建 tag 失败（git tag 返回非零）。"
              exit 1
            }

            # 推送新 tag 到远端：使用简单可靠的推送（直接推 tag 名）
            Write-Host "正在推送 tag 到 origin..."
            git push origin $tag
            if ($LASTEXITCODE -ne 0) {
              Write-Error "推送 tag 到 origin 失败（git push 返回非零）。"
              exit 1
            }

            Write-Host "Tag $tag 已创建并成功推送到 origin。"
          }

          # 将 TAG_NAME 输出到 GitHub Actions 输出变量
          Add-Content -Path $env:GITHUB_OUTPUT -Value "TAG_NAME=$tag"

      - name: 临时修改 src-tauri/Cargo.toml 的版本为 nightly（仅修改 [package] 区块）
        id: patch_cargo_version
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $cargo_path = "src-tauri/Cargo.toml"
          if (-not (Test-Path $cargo_path)) {
            Write-Error "找不到 $cargo_path"
            exit 1
          }

          # 读取并备份（备份已存在时不覆盖）
          $content = Get-Content $cargo_path -Raw -Encoding UTF8
          $backup = ".cargo_backup_src_tauri.toml"
          if (-not (Test-Path $backup)) { Set-Content -Path $backup -Value $content -Encoding UTF8; Write-Host "已备份到 $backup" } else { Write-Host "$backup 已存在，跳过备份覆盖" }

          $nightly = "${{ steps.make_tag_name.outputs.NIGHTLY_VERSION }}"
          Write-Host "将把 [package] 中的 version 修改为: $nightly"

          # 按行拆分，定位 [package] 块并只在该块内部替换 version 行
          $lines = $content -split "\r?\n"
          $inPackage = $false
          $replaced = $false
          for ($i = 0; $i -lt $lines.Length; $i++) {
            $line = $lines[$i]
            if ($line -match '^\s*\[package\]\s*$') {
              $inPackage = $true
              continue
            }
            if ($inPackage -and $line -match '^\s*\[') {
              # 遇到下一个区块，停止在 package 内搜索
              break
            }
            if ($inPackage -and $line -match '^\s*version\s*=') {
              # 替换该行为 nightly 版本（只替换第一个匹配）
              $lines[$i] = "version = `"$nightly`""
              $replaced = $true
              break
            }
          }

          if (-not $replaced) {
            Write-Error "未在 [package] 区块中找到 version 字段，无法写入 nightly 版本。"
            exit 1
          }

          # 写回文件（使用 Unix 换行符）
          $newContent = ($lines -join "`n")
          Set-Content -Path $cargo_path -Value $newContent -Encoding UTF8
          Write-Host "已将 $cargo_path 中 [package] 的 version 设置为 $nightly（仅本地工作区）"

          # 快速校验：确保依赖里没有被误替换成包含 -nightly 的版本号
          $bad = Select-String -Path $cargo_path -Pattern '=\s*".*?-nightly\.\d{8,}' -SimpleMatch -AllMatches
          if ($bad) {
            Write-Host "检测到可能错误：Cargo.toml 中存在带 -nightly 的依赖版本（这通常是不对的）。列出匹配行："
            $bad | ForEach-Object { Write-Host $_.Line }
            # 还原备份以防止后续步骤继续失败
            if (Test-Path $backup) { Get-Content $backup -Raw | Set-Content $cargo_path -Encoding UTF8; Write-Host "已从备份还原 $cargo_path"; }
            Write-Error "发现依赖版本包含 -nightly，已还原并中止构建。请检查 Cargo.toml。"
            exit 1
          } else {
            Write-Host "校验通过：没有在依赖版本中发现 -nightly 字符串。"
          }

          # 导出输出变量
          Add-Content -Path $env:GITHUB_OUTPUT -Value "CARGO_NIGHTLY_VERSION=$nightly"


      - name: 设置 Node.js
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: 设置 Rust (stable)
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: dtolnay/rust-toolchain@stable

      - name: Ensure LLVM (libclang) is available (for bindgen / kcp-sys)
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $llvmBin = Join-Path $env:ProgramFiles "LLVM\\bin"
          if (-not (Test-Path (Join-Path $llvmBin "libclang.dll")) -and -not (Test-Path (Join-Path $llvmBin "clang.dll"))) {
            if (Get-Command choco -ErrorAction SilentlyContinue) {
              Write-Host "Installing LLVM via Chocolatey..."
              choco install llvm -y --no-progress
            } else {
              Write-Host "Chocolatey not found; trying winget..."
              winget install --id LLVM.LLVM -e --accept-source-agreements --accept-package-agreements
            }
          }

          if (-not (Test-Path (Join-Path $llvmBin "libclang.dll")) -and -not (Test-Path (Join-Path $llvmBin "clang.dll"))) {
            throw "LLVM installed but libclang.dll/clang.dll not found under $llvmBin"
          }

          Add-Content -Path $env:GITHUB_PATH -Value $llvmBin
          "LIBCLANG_PATH=$llvmBin" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "LIBCLANG_PATH set to: $llvmBin"

      - name: Ensure 7-Zip is available (for thunk-rs)
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          if (Get-Command 7z -ErrorAction SilentlyContinue) {
            Write-Host "7z already available: $((Get-Command 7z).Source)"
            & 7z -h | Out-Null
            exit 0
          }

          $defaultExe = Join-Path $env:ProgramFiles "7-Zip\\7z.exe"
          if (Test-Path $defaultExe) {
            $dir = Split-Path $defaultExe -Parent
            Add-Content -Path $env:GITHUB_PATH -Value $dir
            Write-Host "Added 7z to PATH: $dir"
            & 7z -h | Out-Null
            exit 0
          }

          Write-Host "7z not found, installing 7zip via Chocolatey..."
          choco install 7zip -y --no-progress
          $dir = Join-Path $env:ProgramFiles "7-Zip"
          Add-Content -Path $env:GITHUB_PATH -Value $dir
          Write-Host "Added 7z to PATH: $dir"
          & 7z -h | Out-Null

      - name: Install Npcap SDK (Packet.lib for pnet on Windows)
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $sdkRoot = Join-Path $env:RUNNER_TEMP "npcap-sdk"
          $zipPath = Join-Path $env:RUNNER_TEMP "npcap-sdk.zip"
          $url = "https://npcap.com/dist/npcap-sdk-1.13.zip"

          if (-not (Test-Path $sdkRoot)) { New-Item -ItemType Directory -Path $sdkRoot | Out-Null }
          if (-not (Test-Path $zipPath)) {
            Write-Host "Downloading Npcap SDK: $url"
            curl.exe -L -o $zipPath $url
          } else {
            Write-Host "Npcap SDK zip already exists: $zipPath"
          }

          Write-Host "Extracting Npcap SDK..."
          & 7z x -aoa $zipPath ("-o{0}" -f $sdkRoot) | Out-Null

          $libDir = Join-Path $sdkRoot "Lib\\x64"
          if (-not (Test-Path (Join-Path $libDir "Packet.lib"))) { throw "Packet.lib not found under $libDir" }
          if (-not (Test-Path (Join-Path $libDir "wpcap.lib"))) { throw "wpcap.lib not found under $libDir" }

          "LIB=$libDir;$env:LIB" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Added to LIB: $libDir"

      - name: 缓存 cargo
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: 安装前端依赖
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm ci
        shell: pwsh

      - name: 全局安装 @tauri-apps/cli（避免使用 npx）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm install -g @tauri-apps/cli
        shell: pwsh

      - name: 构建 Tauri
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        run: npm run tauri:build
        shell: pwsh
        env:
          CI: false
          GDK_RELEASE_KEY: ${{ secrets.GDK_RELEASE_KEY }}
          GDK_PREVIEW_KEY: ${{ secrets.GDK_PREVIEW_KEY }}

      - name: 验证 exe 是否存在并设置输出
        id: find_exe
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          $expected = "src-tauri/target/release/better_minecraft_bedrock_launcher.exe"
          Write-Host "检查文件: $expected"
          if (Test-Path $expected) {
            $p = (Resolve-Path $expected).Path.Replace('\','/')
            Write-Host "找到可执行文件: $p"
            echo "EXE_PATH=$p" >> $env:GITHUB_OUTPUT
            $name = [IO.Path]::GetFileName($p)
            echo "EXE_NAME=$name" >> $env:GITHUB_OUTPUT
          } else {
            Write-Error "未找到期望的 exe 文件: $expected"
            exit 1
          }

      - name: 获取或创建对应的 Release（按 tag）并输出 upload_url
        id: get_or_create_release
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $tag = "${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
          $repo = $env:GITHUB_REPOSITORY
          $headers = @{
            Authorization = "Bearer $env:GH_TOKEN"
            "User-Agent" = "github-actions"
            Accept = "application/vnd.github+json"
          }
          Write-Host "查找 tag 对应的 Release：$tag"
          try {
            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/tags/$tag" -Headers $headers -ErrorAction Stop
            Write-Host "找到已存在的 Release (id=$($release.id))"
          } catch {
            Write-Host "未找到 Release，准备创建新的 pre-release..."
          
            $body = @{
              tag_name  = $tag
              name      = "Nightly $tag"
               body = "自动化 nightly 预发行：$tag。"
              draft     = $false
              prerelease= $true
            } | ConvertTo-Json -Depth 6
          
            $release = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases" -Headers $headers -Method Post -Body $body
            Write-Host "已创建 Release (id=$($release.id))"
          }
          echo "RELEASE_ID=$($release.id)" >> $env:GITHUB_OUTPUT
          echo "UPLOAD_URL=$($release.upload_url)" >> $env:GITHUB_OUTPUT

      - name: 删除 Release 中同名旧资产（如果存在）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $repo = $env:GITHUB_REPOSITORY
          $release_id = "${{ steps.get_or_create_release.outputs.RELEASE_ID }}"
          $filename = "${{ steps.find_exe.outputs.EXE_NAME }}"
          $headers = @{
            Authorization = "Bearer $env:GH_TOKEN"
            "User-Agent" = "github-actions"
            Accept = "application/vnd.github+json"
          }

          Write-Host "列出 Release($release_id) 的资产并检查是否存在同名文件: $filename"
          $assets = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/$release_id/assets" -Headers $headers
          if ($assets) {
            foreach ($a in $assets) {
              if ($a.name -eq $filename) {
                Write-Host "发现同名资产 (id=$($a.id))，正在删除..."
                Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/assets/$($a.id)" -Headers $headers -Method Delete
                Write-Host "已删除旧资产 $filename (id=$($a.id))"
              }
            }
          } else {
            Write-Host "Release 中没有资产。"
          }

      - name: 上传 exe 到 GitHub Release（创建或更新 Release，统一 body）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}
          name: "Nightly ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
          body: |
            这是一个仅供开发者和测试者使用的夜间构建版本！

            普通用户应该下载最新的稳定版本，而不是这个夜间构建版本。

            ---
            
            ⚠️ 重要说明：
            
            - 此版本可能包含不稳定功能或错误
            - 不推荐用于生产环境
            - 功能可能未经通知而更改或删除
          draft: false
          prerelease: true
          files: ${{ steps.find_exe.outputs.EXE_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 清理旧 nightly tags 和 Release 资产（仅保留当前 tag）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          # 不要在这里因为删除失败而中止整个 job：尽量删除但允许运行继续
          $ErrorActionPreference = "Continue"

          $repo = $env:GITHUB_REPOSITORY
          $currentTag = "${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
          Write-Host "当前要保留的 tag: $currentTag"

          # 确保本地有最新 tags
          git fetch --tags origin

          # 按创建时间降序列出所有 nightly tag（最新在前）
          $tags = git tag -l "v*-nightly.*" --sort=-creatordate
          if (-not $tags) {
            Write-Host "未找到任何 nightly tags，跳过清理。"
            exit 0
          }

          $headers = @{
            Authorization = "Bearer $env:GH_TOKEN"
            "User-Agent" = "github-actions"
            Accept = "application/vnd.github+json"
          }

          foreach ($t in $tags) {
            if ($t -eq $currentTag) {
              Write-Host "跳过当前 tag: $t"
              continue
            }

            Write-Host "准备删除旧 nightly tag: $t"

            # 1) 尝试删除与该 tag 对应的 Release（如果存在）
            try {
              $rel = Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/tags/$t" -Headers $headers -ErrorAction Stop
              if ($rel -and $rel.id) {
                Write-Host "找到 Release id=$($rel.id) -> 删除 Release..."
                Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/releases/$($rel.id)" -Headers $headers -Method Delete -ErrorAction Stop
                Write-Host "已删除 Release (id=$($rel.id))"
              }
            } catch {
              Write-Host "未找到 Release 或删除 Release 失败（可忽略）: $($_.Exception.Message)"
            }

            # 2) 删除远程 git ref（refs/tags/<tag>）
            try {
              Write-Host "尝试通过 GitHub API 删除远程 tag ref: refs/tags/$t"
              Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/git/refs/tags/$t" -Headers $headers -Method Delete -ErrorAction Stop
              Write-Host "已删除远程 tag refs/tags/$t"
            } catch {
              Write-Host "通过 API 删除 refs/tags/$t 失败或不存在: $($_.Exception.Message)"
              # fallback: 尝试 git push origin --delete <tag>
              try {
                git push origin --delete $t
                Write-Host "通过 git push origin --delete $t 删除成功"
              } catch {
                Write-Host "git push --delete 失败: $($_.Exception.Message)"
              }
            }

            try {
              git tag -d $t 2>$null
            } catch {
              # 忽略
            }
          }

          Write-Host "旧 nightly tag 清理完成。"

      - name: 还原原始 src-tauri/Cargo.toml（恢复版本）
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          if (Test-Path ".cargo_backup_src_tauri.toml") {
            Get-Content ".cargo_backup_src_tauri.toml" -Raw | Set-Content "src-tauri/Cargo.toml" -Encoding UTF8
            Write-Host "已从 .cargo_backup_src_tauri.toml 恢复 src-tauri/Cargo.toml"
            Remove-Item ".cargo_backup_src_tauri.toml" -ErrorAction SilentlyContinue
          } else {
            Write-Host "未找到 .cargo_backup_src_tauri.toml，跳过恢复。"
          }

      - name: 完成提示
        if: ${{ steps.check_commits.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          Write-Host "Nightly 预发行已上传并使用 tag: ${{ steps.create_or_reuse_tag.outputs.TAG_NAME }}"
