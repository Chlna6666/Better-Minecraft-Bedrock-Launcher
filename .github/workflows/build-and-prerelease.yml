name: build-and-prerelease

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build_windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Restore npm cache (optional)
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies (npm)
        run: npm ci --ignore-scripts
        shell: pwsh

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo (registry, git, target, bin)
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/bin
            src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install Tauri CLI
        run: cargo install tauri-cli --locked || true

      - name: Show environment (debug)
        run: |
          Write-Host "cargo: $(Get-Command cargo).Path"
          if (Get-Command tauri -ErrorAction SilentlyContinue) {
            Write-Host "tauri: $(Get-Command tauri).Path"
          } else {
            Write-Host "tauri not in PATH; listing ~/.cargo/bin"
            Get-ChildItem $env:USERPROFILE\.cargo\bin | ForEach-Object { Write-Host $_.FullName }
          }
        shell: pwsh

      - name: Build Tauri App
        run: |
          cargo tauri build
        working-directory: .
        shell: pwsh

      - name: Collect build artifacts (copy to build/)
        run: |
          if (-not (Test-Path -Path build)) { New-Item -ItemType Directory -Path build | Out-Null }

          # 复制 target/release 下的 exe（若存在）
          if (Test-Path "src-tauri/target/release") {
            Get-ChildItem src-tauri/target/release -Filter *.exe -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination build -Force -ErrorAction SilentlyContinue
            }
          }

          # 复制 bundle 下所有可能的安装器（msi, nsis, zip, exe）
          if (Test-Path "src-tauri/target/release/bundle") {
            Copy-Item -Path src-tauri/target/release/bundle/** -Destination build -Recurse -Force -ErrorAction SilentlyContinue
          }

          # 也尝试复制根 target/release（如果项目以不同方式输出）
          if (Test-Path "target/release") {
            Get-ChildItem target/release -Filter *.exe -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination build -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host "===== build/ contents ====="
          Get-ChildItem build -Recurse | ForEach-Object { Write-Host $_.FullName }
        shell: pwsh

      - name: list target directories
        run: |
          Write-Host "=== src-tauri/target/release ==="
          if (Test-Path "src-tauri/target/release") { Get-ChildItem src-tauri/target/release -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "not found" }
          Write-Host "=== src-tauri/target/release/bundle ==="
          if (Test-Path "src-tauri/target/release/bundle") { Get-ChildItem src-tauri/target/release/bundle -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "not found" }
        shell: pwsh

      - name: Get version via cargo metadata (robust, workspace-safe)
        id: get_version
        shell: pwsh
        run: |
          Write-Host "=== Extracting package version (robust) ==="

          $v = $null

          # 1) Try cargo metadata with explicit manifest-path for src-tauri
          if (Test-Path "src-tauri/Cargo.toml") {
            Write-Host "Trying: cargo metadata --manifest-path src-tauri/Cargo.toml ..."
            $meta_json = & cargo metadata --manifest-path src-tauri/Cargo.toml --no-deps --format-version 1 2>$null
            if ($LASTEXITCODE -eq 0 -and $meta_json) {
              try {
                $meta = $meta_json | ConvertFrom-Json
                if ($meta.packages.Count -gt 0) {
                  # typically the first package is the one
                  $v = $meta.packages[0].version
                  Write-Host ("Found version from src-tauri manifest package: {0}" -f $v)
                } else {
                  Write-Host "cargo metadata returned no packages for src-tauri manifest"
                }
              } catch {
                Write-Host "Failed to parse cargo metadata JSON for src-tauri: $_"
              }
            } else {
              Write-Host "cargo metadata (src-tauri) failed or returned empty."
            }
          } else {
            Write-Host "src-tauri/Cargo.toml not found, skipping manifest-path attempt."
          }

          # 2) Try cargo metadata in repo root (if not found yet)
          if (-not $v) {
            Write-Host "Trying: cargo metadata (repo root) ..."
            $meta_json = & cargo metadata --no-deps --format-version 1 2>$null
            if ($LASTEXITCODE -eq 0 -and $meta_json) {
              try {
                $meta = $meta_json | ConvertFrom-Json
                # prefer a package whose manifest_path contains src-tauri
                $pkg = $meta.packages | Where-Object { $_.manifest_path -like "*src-tauri*/Cargo.toml" } | Select-Object -First 1
                if (-not $pkg) { $pkg = $meta.packages | Select-Object -First 1 }
                if ($pkg) {
                  $v = $pkg.version
                  Write-Host ("Found version from cargo metadata: {0} (package manifest: {1})" -f $v, $pkg.manifest_path)
                } else {
                  Write-Host "No package found in cargo metadata result"
                }
              } catch {
                Write-Host "Failed to parse cargo metadata JSON (root): $_"
              }
            } else {
              Write-Host "cargo metadata (root) failed or returned empty."
            }
          }

          # 3) Fallback: parse src-tauri/Cargo.toml or root Cargo.toml via Select-String (robust)
          if (-not $v) {
            Write-Host "Falling back to text parse of Cargo.toml files..."
            $paths = @()
            if (Test-Path "src-tauri/Cargo.toml") { $paths += "src-tauri/Cargo.toml" }
            if (Test-Path "Cargo.toml") { $paths += "Cargo.toml" }

            foreach ($p in $paths) {
              Write-Host ("Searching for version in {0}" -f $p)
              $m = Select-String -Path $p -Pattern '^\s*version\s*=\s*"(.*?)"' -AllMatches
              if ($m -and $m.Matches.Count -gt 0) {
                $v = $m.Matches[0].Groups[1].Value
                Write-Host ("Found version in {0}: {1}" -f $p, $v)
                break
              } else {
                Write-Host ("No version= found in {0}" -f $p)
              }
            }
          }

          if (-not $v) {
            Write-Host "WARNING: Unable to detect package version; defaulting to 0.0.0"
            $v = "0.0.0"
          }

          Write-Host ("Final extracted version: {0}" -f $v)
          echo "version=$v" >> $env:GITHUB_OUTPUT


      - name: Find exact build files (only main exe + nsis setup)
        id: find_build_files
        shell: pwsh
        run: |
          Write-Host "Looking for main exe and nsis setup installer..."

          $files = @()

          # 1) main exe (expected path)
          $main = "src-tauri/target/release/better_minecraft_bedrock_launcher.exe"
          if (Test-Path $main) {
            $p = (Resolve-Path $main).Path -replace "\\","/"
            Write-Host ("Found main exe: {0}" -f $p)
            $files += $p
          } else {
            Write-Host "Main exe not found at $main"
          }

          # 2) nsis setup installer (search bundle/nsis and other bundle subdirs)
          $nsisCandidate = Get-ChildItem "src-tauri/target/release/bundle" -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object {
              $_.Name -match '^better_minecraft_bedrock_launcher.*-setup\.exe$' -and ($_.FullName -match '\\nsis\\' -or $_.FullName -match '/nsis/')
            } | Select-Object -First 1

          if ($nsisCandidate) {
            $p2 = $nsisCandidate.FullName -replace "\\","/"
            Write-Host ("Found nsis installer: {0}" -f $p2)
            $files += $p2
          } else {
            Write-Host "NSIS installer not found under src-tauri/target/release/bundle/*/nsis/"
          }

          if ($files.Count -eq 0) {
            Write-Host "No target files found — outputting empty files variable."
            echo "files=" >> $env:GITHUB_OUTPUT
            exit 0
          }

          $joined = [string]::Join(',', $files)
          Write-Host ("Files to upload: {0}" -f $joined)
          echo "files=$joined" >> $env:GITHUB_OUTPUT

      - name: Create Pre-release and upload selected assets
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ steps.get_version.outputs.version }}-pre
          name: "Pre-release v${{ steps.get_version.outputs.version }}"
          artifacts: ${{ steps.find_build_files.outputs.files }}
          draft: false
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

