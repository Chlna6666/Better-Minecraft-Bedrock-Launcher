name: build-and-prerelease

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build_windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Restore npm cache (optional)
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies (npm)
        run: npm ci --ignore-scripts
        shell: pwsh

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo (registry, git, target, bin)
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/bin
            src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install Tauri CLI (if missing)
        shell: pwsh
        run: |
          Write-Host "Check tauri/cargo-tauri in PATH..."
          $found = $false
          if (Get-Command tauri -ErrorAction SilentlyContinue) {
            Write-Host "Found 'tauri' command: $(Get-Command tauri).Path"
            $found = $true
          }
          if (-not $found -and (Get-Command cargo-tauri -ErrorAction SilentlyContinue)) {
            Write-Host "Found 'cargo-tauri' command: $(Get-Command cargo-tauri).Path"
            $found = $true
          }
          if ($found) {
            Write-Host "Tauri CLI already present - skipping install."
          } else {
            Write-Host "Tauri CLI not found - installing (best-effort)..."
            & cargo install tauri-cli --locked --force
            if ($LASTEXITCODE -ne 0) {
              Write-Host "cargo install returned exit code $LASTEXITCODE; continuing anyway."
            } else {
              Write-Host "tauri-cli installed."
            }
          }

      - name: Show environment (debug)
        run: |
          Write-Host "cargo: $(Get-Command cargo).Path"
          if (Get-Command tauri -ErrorAction SilentlyContinue) {
            Write-Host "tauri: $(Get-Command tauri).Path"
          } else {
            Write-Host "tauri not in PATH; listing ~/.cargo/bin"
            Get-ChildItem $env:USERPROFILE\.cargo\bin | ForEach-Object { Write-Host $_.FullName }
          }
        shell: pwsh

      - name: Build Tauri App
        run: |
          cargo tauri build
        working-directory: .
        shell: pwsh

      - name: Collect build artifacts (copy to build/)
        run: |
          if (-not (Test-Path -Path build)) { New-Item -ItemType Directory -Path build | Out-Null }

          # 复制 src-tauri/target/release 下的 exe（若存在）
          if (Test-Path "src-tauri/target/release") {
            Get-ChildItem src-tauri/target/release -Filter *.exe -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination build -Force -ErrorAction SilentlyContinue
            }
          }

          # 复制 bundle 下所有安装器文件
          if (Test-Path "src-tauri/target/release/bundle") {
            Copy-Item -Path src-tauri/target/release/bundle/** -Destination build -Recurse -Force -ErrorAction SilentlyContinue
          }

          # 根 target/release 作为备用
          if (Test-Path "target/release") {
            Get-ChildItem target/release -Filter *.exe -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination build -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host "===== build/ contents ====="
          Get-ChildItem build -Recurse | ForEach-Object { Write-Host $_.FullName }
        shell: pwsh

      - name: list target directories (debug)
        run: |
          Write-Host "=== src-tauri/target/release ==="
          if (Test-Path "src-tauri/target/release") { Get-ChildItem src-tauri/target/release -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "not found" }
          Write-Host "=== src-tauri/target/release/bundle ==="
          if (Test-Path "src-tauri/target/release/bundle") { Get-ChildItem src-tauri/target/release/bundle -Recurse | ForEach-Object { Write-Host $_.FullName } } else { Write-Host "not found" }
        shell: pwsh

      - name: Get version via cargo metadata (robust, workspace-safe)
        id: get_version
        shell: pwsh
        run: |
          Write-Host "=== Extracting package version (robust) ==="

          $v = $null

          # 1) Try cargo metadata with explicit manifest-path for src-tauri
          if (Test-Path "src-tauri/Cargo.toml") {
            Write-Host "Trying: cargo metadata --manifest-path src-tauri/Cargo.toml ..."
            $meta_json = & cargo metadata --manifest-path src-tauri/Cargo.toml --no-deps --format-version 1 2>$null
            if ($LASTEXITCODE -eq 0 -and $meta_json) {
              try {
                $meta = $meta_json | ConvertFrom-Json
                if ($meta.packages.Count -gt 0) {
                  $v = $meta.packages[0].version
                  Write-Host ("Found version from src-tauri manifest package: {0}" -f $v)
                } else {
                  Write-Host "cargo metadata returned no packages for src-tauri manifest"
                }
              } catch {
                Write-Host "Failed to parse cargo metadata JSON for src-tauri: $_"
              }
            } else {
              Write-Host "cargo metadata (src-tauri) failed or returned empty."
            }
          } else {
            Write-Host "src-tauri/Cargo.toml not found, skipping manifest-path attempt."
          }

          # 2) Try cargo metadata in repo root (if not found yet)
          if (-not $v) {
            Write-Host "Trying: cargo metadata (repo root) ..."
            $meta_json = & cargo metadata --no-deps --format-version 1 2>$null
            if ($LASTEXITCODE -eq 0 -and $meta_json) {
              try {
                $meta = $meta_json | ConvertFrom-Json
                $pkg = $meta.packages | Where-Object { $_.manifest_path -like "*src-tauri*/Cargo.toml" } | Select-Object -First 1
                if (-not $pkg) { $pkg = $meta.packages | Select-Object -First 1 }
                if ($pkg) {
                  $v = $pkg.version
                  Write-Host ("Found version from cargo metadata: {0} (package manifest: {1})" -f $v, $pkg.manifest_path)
                } else {
                  Write-Host "No package found in cargo metadata result"
                }
              } catch {
                Write-Host "Failed to parse cargo metadata JSON (root): $_"
              }
            } else {
              Write-Host "cargo metadata (root) failed or returned empty."
            }
          }

          # 3) Fallback: text parse
          if (-not $v) {
            Write-Host "Falling back to text parse of Cargo.toml files..."
            $paths = @()
            if (Test-Path "src-tauri/Cargo.toml") { $paths += "src-tauri/Cargo.toml" }
            if (Test-Path "Cargo.toml") { $paths += "Cargo.toml" }
            foreach ($p in $paths) {
              Write-Host ("Searching for version in {0}" -f $p)
              $m = Select-String -Path $p -Pattern '^\s*version\s*=\s*"(.*?)"' -AllMatches
              if ($m -and $m.Matches.Count -gt 0) {
                $v = $m.Matches[0].Groups[1].Value
                Write-Host ("Found version in {0}: {1}" -f $p, $v)
                break
              } else {
                Write-Host ("No version= found in {0}" -f $p)
              }
            }
          }

          if (-not $v) {
            Write-Host "WARNING: Unable to detect package version; defaulting to 0.0.0"
            $v = "0.0.0"
          }

          Write-Host ("Final extracted version: {0}" -f $v)
          echo "version=$v" >> $env:GITHUB_OUTPUT

      - name: Find exact build files (only main exe + nsis setup)
        id: find_build_files
        shell: pwsh
        run: |
          Write-Host "Looking for main exe and nsis setup installer..."
          $files = @()

          # main exe
          $main = "src-tauri/target/release/better_minecraft_bedrock_launcher.exe"
          if (Test-Path $main) {
            $p = (Resolve-Path $main).Path -replace "\\","/"
            Write-Host ("Found main exe: {0}" -f $p)
            $files += $p
          } else {
            Write-Host "Main exe not found at $main"
          }

          # nsis installer
          $nsisCandidate = Get-ChildItem "src-tauri/target/release/bundle" -Recurse -File -ErrorAction SilentlyContinue |
            Where-Object {
              $_.Name -match '^better_minecraft_bedrock_launcher.*-setup\.exe$' -and ($_.FullName -match '\\nsis\\' -or $_.FullName -match '/nsis/')
            } | Select-Object -First 1

          if ($nsisCandidate) {
            $p2 = $nsisCandidate.FullName -replace "\\","/"
            Write-Host ("Found nsis installer: {0}" -f $p2)
            $files += $p2
          } else {
            Write-Host "NSIS installer not found under src-tauri/target/release/bundle/*/nsis/"
          }

          if ($files.Count -eq 0) {
            Write-Host "No target files found — outputting empty files variable."
            echo "files=" >> $env:GITHUB_OUTPUT
            exit 0
          }

          $joined = [string]::Join(',', $files)
          Write-Host ("Files to upload: {0}" -f $joined)
          echo "files=$joined" >> $env:GITHUB_OUTPUT

      - name: (Optional) Remove same-named assets from existing release (prevent duplicates)
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          VERSION: ${{ steps.get_version.outputs.version }}
        run: |
          $tag = "v${{ steps.get_version.outputs.version }}-pre"
          Write-Host "Preparing release tag: $tag"

          # 确认 gh 可用
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            Write-Error "gh CLI not found on runner. Aborting deletion step."
            exit 1
          }

          # patterns to match existing asset names (use -like; supports '*' wildcard)
          $targetPatterns = @(
            "better_minecraft_bedrock_launcher.exe",
            "better_minecraft_bedrock_launcher_*_*-setup.exe"
          )

          # 尝试获取 release 的 assets（用 try/catch 避免在不存在时抛错）
          $exists = $false
          $json = $null
          try {
            # 注意：在 pwsh 中将 stderr 丢弃要用 2>$null（不要用 >/dev/null）
            $json = gh release view $tag --json assets 2>$null
            if ($LASTEXITCODE -eq 0 -and -not [string]::IsNullOrWhiteSpace($json)) {
              $exists = $true
            }
          } catch {
            $exists = $false
          }

          if (-not $exists) {
            Write-Host "Release $tag does not exist — nothing to delete."
            exit 0
          }

          Write-Host "Release $tag exists — checking assets to delete matching patterns..."

          # 解析 assets JSON（如果为空也要保护）
          $obj = $null
          try {
            $obj = $json | ConvertFrom-Json
          } catch {
            Write-Host "Failed to parse release JSON; skipping deletion."
            exit 0
          }

          $existing = @($obj.assets)

          foreach ($a in $existing) {
            foreach ($pat in $targetPatterns) {
              try {
                if ($a.name -like $pat) {
                  Write-Host ("Deleting existing asset: {0} (id={1})" -f $a.name, $a.id)
                  # 使用 gh api 删除 asset（若失败则记录并继续）
                  gh api --method DELETE "/repos/${{ github.repository }}/releases/assets/$($a.id)" 2>$null
                  if ($LASTEXITCODE -ne 0) {
                    Write-Host "Warning: failed to delete asset id $($a.id) (name $($a.name)), continuing..."
                  } else {
                    Write-Host "Deleted asset: $($a.name)"
                  }
                  break
                }
              } catch {
                Write-Host "Error while checking/deleting asset $($a.name): $_"
              }
            }
          }

          Write-Host "Asset deletion step finished."

      - name: Create pre-release & upload selected assets (softprops/action-gh-release)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_version.outputs.version }}-pre
          name: "Pre-release v${{ steps.get_version.outputs.version }}"
          prerelease: true
          files: |
            src-tauri/target/release/better_minecraft_bedrock_launcher.exe
            src-tauri/target/release/bundle/**/better_minecraft_bedrock_launcher_*_*-setup.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
